# haySTACK

> Help! I've lost my favorite needle!
>
> nc pwn.chal.csaw.io 5002

## Description

We are given the binary. We give it to Ghidra to get the disassembled code:

*Note: I renamed functions and variables for clarity*.

```c
void init_stack(void)
{
  long lVar1;
  long in_FS_OFFSET;
  int iVar2;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  iVar2 = 0;
  while (iVar2 < 0x100000) {
    *(undefined4 *)(&stack0xffffffffffbfffe8 + (long)iVar2 * 4) = 0xb00;
    iVar2 = iVar2 + 1;
  }
  challenge(&stack0xffffffffffbfffe8);
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

```

This one initialises an array of size 0x100000 filled with 0xb00, then calls `challenge`.

```c
void challenge(long stack)
{
  int iVar1;
  int iVar2;
  long in_FS_OFFSET;
  int local_44;
  undefined8 local_38;
  undefined8 local_30;
  undefined8 local_28;
  undefined8 local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  iVar1 = random_value();
  *(undefined4 *)(stack + (long)iVar1 * 4) = 0x1337;
  local_38 = 0;
  local_30 = 0;
  local_28 = 0;
  local_20 = 0;
  local_44 = 0;
  do {
    if (2 < local_44) {
LAB_00101429:
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return;
    }
    fwrite("Which haystack do you want to check?\n",1,0x25,stdout);
    fgets((char *)&local_38,0x20,stdin);
    iVar2 = atoi((char *)&local_38);
    if (iVar2 < 0x100001) {
      if (iVar2 == iVar1) {
        printf("Hey you found a needle! And its number is 0x%08x! That\'s it!\n",
               (ulong)*(uint *)(stack + (long)iVar2 * 4));
        win();
      }
      else {
        printf("Hey, you found a needle, but it\'s number is 0x%08x. I don\'t like that one\n",
               (ulong)*(uint *)(stack + (long)iVar2 * 4));
        if (local_44 == 0) {
          puts(
              "Shoot, I forgot to tell you that I hid a needle in every stack. But I only have onefavorite needle"
              );
        }
        else {
          if (local_44 == 1) {
            puts("Did I mention I\'m in a hurry? I need you to find it on your next guess");
          }
        }
      }
    }
    else {
      fwrite("I don\'t have that many haystacks!\n",1,0x22,stdout);
    }
    if (local_44 == 2) {
      puts("I\'m out of time. Thanks for trying...");
      goto LAB_00101429;
    }
    puts("Let\'s try again!");
    local_44 = local_44 + 1;
  } while( true );
}
```

This function first chooses a random value between 0 and 0x100000, and sets the corresponding array value to 0x1337.
This is performed by those lines:

```c
iVar1 = random_value();
*(undefined4 *)(stack + (long)iVar1 * 4) = 0x1337;
```

with `random_value` defined as follows:
```c
ulong random_value(void)
{
  long lVar1;
  int iVar2;
  time_t tVar3;
  long in_FS_OFFSET;
  
  lVar1 = *(long *)(in_FS_OFFSET + 0x28);
  tVar3 = time((time_t *)0x0);
  srand((uint)tVar3);
  iVar2 = rand();
  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return (long)iVar2 % 0x100000 & 0xffffffff;
}
```

Then we get 3 tries for finding the number generated by `random_value`. If this works, the `win` function is called and gives the flag.

## Solution

The goal is thus to predict the correct number.
We can do this because we know how the PRNG is initialized:
```c
tVar3 = time((time_t *)0x0);
srand((uint)tVar3);
iVar2 = rand();
```

So the PRNG is initialized using the current time (in seconds). So we can perform the same initialization on our local machine and thus get the same random number generated.

However, there could be some offset between my machine and the server, so I will basically brute force this offset (it should not be that big).

### Step 1: create a C program to generate random numbers.

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(int argc, char **argv) {
    int offset = atoi(argv[1]);
    time_t t = time(NULL);
    for(int i=0;i<3;++i) {
        srand(t + offset + i);
        printf("%d ", rand() % 0x100000 & 0xffffffff);
    }
    puts("\n");
    return 0;
}
```

I compile it with `gcc -o rand rand.c`

### Step 2: Python exploit

```python
from pwn import *
import os


for OFFSET in range(-10,10,3):

    values = os.popen("./rand {}".format(OFFSET)).read()
    sh = remote("pwn.chal.csaw.io", 5002)

    values = values.strip().split(" ")
    print(values)

    for v in values:
        sh.recvuntil("check?")
        sh.sendline(v)
        sh.recvuntil("Hey")
        answer = "Hey" + sh.recvline().decode()
        print(answer)
        if "That's it" in answer:
            sh.interactive()
```

Flag: `flag{4lw4YS_r3m3mB3R_2_ch3CK_UR_st4cks}`